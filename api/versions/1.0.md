FLOWFACT Restful API Guidelines
===============================

TODO


## Introduction

TODO


# Principles

TODO


# Guidelines

The guideline titles are marked with the following labels: `MUST`, `SHOULD`, or `MAY`.
They reflect the requirement of corresponding guideline and is to be interpreted as described in [RFC 2119](https://tools.ietf.org/html/rfc2119).

TODO

## General Guidelines

### `SHOULD` Follow API First Principle

You must follow the API First Principle, more specifically:
* When implementing a new or modifying an existing REST service or parts of it − thus modifying the API −,
you must obtain approval by review by at least one API expert.
* You must design your APIs consistently with this guidelines.

The review must assert that the modification is consistent with all guidelines in this document.

TODO

### `MUST` Provide API Specification Using OpenAPI

When implementing a new or modifying an existing REST service or parts of it,
annotate it with meaningful [Swagger](https://swagger.io/) documentation.
The documentation must provide sufficient information to enable any developer to use the REST endpoint(s).
For Swagger in particular it must include:
* for each REST controller:
  * `io.swagger.annotations.Api`
* for each REST endpoint:
  * `io.swagger.annotations.ApiOperation`
  * for all probable HTTP response codes:
    * `io.swagger.annotations.ApiResponses`
  * for each parameter:
    * `io.swagger.annotations.ApiParam`
    * for any validation:
      * make sure that all constraints are clearly defined in description
* for each REST model (consumed or produced by an endpoint):
  * `io.swagger.annotations.ApiModel`
    * for each field:
      * `io.swagger.annotations.ApiModelProperty`

### `MUST` Write APIs in U.S. or British English


## Security


### `SHOULD` Secure Endpoints

The API endpoint (with only a few exceptions) needs to be secured by one or more of the following methods:
* [AWS Cognito](https://aws.amazon.com/)
* [BasicAuth](https://en.wikipedia.org/wiki/Basic_access_authentication)

If an API endpoints is destined to be not secure, it must be,
and only be accessible via an absolute REST path starting with `/public/`.


## Compatibility

### `MUST` Don't Break Backward Compatibility<a name="chapter_dont_break_backward_compatibility"></a>

You may change the API, but keep all customers (API clients) running.
Keep in mind that the API is a contract between the service provider and service consumer (a.k.a. client).

Whenever changing the API, do it by adding compatible extensions.
In the case that this is not a choice,
introduce a new API version while still supporting older versions.

And we strongly encourage you to refrain to compatible extensions and also discourage versioning.

**Note:**
The following guidelines discuss the various aspects of how to preserve compatiblity.
They however do not cover incompatible changes but only breaking changes.
Breaking changes are incompatible changes deployed into operation,
and thereby breaking the API contract for consumers.
However, an incompatible change may not ever be deployed into the production lifecycle.

### `MUST` Prefer Compatible Extensions

With each and every modification, the API should evolve in a backward-compatible way:
* Add only optional, never mandatory fields.
* Never change the semantic of fields (e.g. changing the semantic from entity ID to
entity name)
* Never change the validation logic to be more restrictive.
* Enum ranges:
  * can be reduced when used as input parameters,
    only if the endpoint is ready to accept and handle old range values too.
  * can be reduced when used as output parameters.
  * cannot be extended when used for output parameters — clients may not be prepared to handle it.
    However, enum ranges can be extended when used for input parameters.
* Use `x-extensible-enum`, if range is used for output parameters and likely to be extended with growing functionality.
  It defines an open list of explicit values and clients must be agnostic to new values.
* Support redirection in case an URL has to change [`301`](#status_code_301).

### `MUST` Prepare Clients To Not Crash On Compatible API Extensions

Clients should apply the [Robustness Principle](https://en.wikipedia.org/wiki/Robustness_principle):
* Be conservative with API requests and data passed as input, e.g. avoid to exploit definition
deficits like passing megabytes of strings with unspecified maximum length.
* Be tolerant in processing and reading data of API responses

Clients must be prepared for compatible API extensions of service providers:
* Be tolerant with unknown fields in the payload (see also [Fowler's TolerantReader post](https://martinfowler.com/bliki/TolerantReader.html)),
i.e. ignore new fields but do not eliminate them from payload if needed for subsequent `PUT` requests.
* Be prepared that `x-extensible-enum` return parameter may deliver new values;
  either be agnostic or provide default behavior for unknown values.
* Be prepared to handle HTTP status codes not explicitly specified in endpoint definitions.
  Note also, that status codes are extensible.
  Default handling is how you would treat the corresponding code (see [RFC 7231 Section 6](https://tools.ietf.org/html/rfc7231)).
* Follow the redirect when the server returns HTTP status code [`301`](#status_code_301).

### `SHOULD` Design APIs Conservatively
The API should be conservative and accurate in what it accepts from clients:
* Unknown input fields in payload or URL should not be ignored;
  servers should provide error feedback to clients via an HTTP `400` response code.
* Be accurate in defining input data constraints (like formats, ranges, lengths etc.) —
  and check constraints and return dedicated error information in case of violations.
* Prefer being more specific and restrictive (if compliant to functional requirements),
  e.g. by defining length range of strings.
  It may simplify implementation while providing freedom for further evolution as compatible extensions.

Not ignoring unknown input fields is a specific deviation from [Postel's Law](https://en.wikipedia.org/wiki/Robustness_principle) (e.g. see also [The Robustness Principle Reconsidered](https://cacm.acm.org/magazines/2011/8/114933-the-robustness-principle-reconsidered/fulltext)) and a strong recommendation.
The API might want to take a different approach but should be aware of the following problems and be explicit in what is supported:
* Ignoring unknown input fields is actually not an option for `PUT`,
  since it becomes asymmetric with subsequent `GET` response and HTTP is clear about the `PUT` replace semantics and default roundtrip expectations (see [RFC 7231 Section 4.3.4](https://tools.ietf.org/html/rfc7231)).
  Note, accepting (i.e. not ignoring) unknown input fields and returning it in subsequent `GET` responses is a different situation and compliant to `PUT` semantics.
* Certain client errors cannot be recognized by servers,
  e.g. attribute name typing errors will be ignored without server error feedback.
  The server cannot differentiate between the client intentionally providing an additional field versus the client sending a mistakenly named field,
  when the client's actual intent was to provide an optional input field.
* Future extensions of the input data structure might be in conflict with already ignored fields and,
  hence, will not be compatible,
  i.e. break clients that already use this field but with different type.

In specific situations, where a (known) input field is not needed anymore,
it either can stay in the API definition with "not used anymore" description or can be removed from the API definition as long as the server ignores this specific parameter.

### `MUST` Always Return JSON Objects As Top-Level Data Structures To Support Extensibility

**Always** return a JSON object (and not e.g. an array) as a top level data structure to support future extensibility.

### `SHOULD` Use Open-Ended List of Values Instead of Enumerations

Enumerations are per definition closed sets of values,
that are assumed to be complete and not intended for extension.
This closed principle of enumerations imposes compatibility issues when an enumeration must be extended.
To avoid these issues, we strongly recommend to use an open-ended list of values instead of an enumeration.

To specify an open-ended list of values use the marker x-extensible-enum as follows:
```
deliver_methods:
  type: string
  x-extensible-enum:
    - parcel
    - letter
    - email
```
**Note:** `x-extensible-enum` is not JSON Schema conform but will be ignored by most tools.

### `SHOULD` Avoid Versioning

Only if the modification cannot absolutely be done in a compatible way,
introduce a new version as it complicates things,
and significantly increases testing, operating, and maintenance efforts.
Proceed in one of these three ways:
* create a new resource (variant) in addition to the old resource variant
* create a new service endpoint — i.e. a new application with a new API (with a new domain name)
* create a new API version supported in parallel with the old API by the same microservice

As we discourage versioning by all means because of the manifold disadvantages,
we strongly recommend to only use the first two approaches.

### `MUST` Use Media Type Versioning

However, when API versioning is unavoidable,
you have to design your multi-version APIs using media type versioning (instead of URI versioning, see below).
Media type versioning is less tightly coupled since it supports content negotiation and hence reduces complexity of release management.

Media type versioning: Here, version information and media type are provided together via the HTTP Content-Type header — e.g. `application/x.flowfact.schema+json;version=2`.
For incompatible changes, a new media type version for the resource is created.
To generate the new representation version,
consumer and producer can do content negotiation using the HTTP `Content-Type` and `Accept` headers.

**Note:** This versioning only applies to the request and response content schema,
not to URI or method semantics.

In this example, a client wants only the new version of the response:
```
Accept: application/x.flowfact.schema+json;version=2
```
A server responding to this, as well as a client sending a request with content should use the `Content-Type` header, declaring that one is sending the new version:
```
Content-Type: application/x.flowfact.schema+json;version=2
```
Using header versioning should:
* include versions in request and response headers to increase visibility
* include Content-Type in the Vary header to enable proxy caches to differ between versions

**Hint:** Until an incompatible change is necessary, it is recommended to stay with the standard `application/json` media type.

Further reading: [API Versioning Has No "Right Way"](https://blog.apisyouwonthate.com/api-versioning-has-no-right-way-f3c75457c0b7) provides an overview on different versioning approaches to handle breaking changes without being opinionated.

### `MUST` Do Not Use URI Versioning

With URI versioning a (major) version number is included in the path, e.g. `/v1/customers`.
The consumer has to wait until the provider has been released and deployed.
If the consumer also supports hypermedia links — even in their APIs — to drive workflows ([HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)),
this quickly becomes complex.
So does coordinating version upgrades — especially with hyperlinked service dependencies — when using URL versioning.
To avoid this tighter coupling and complexer release management we do not use URI versioning,
and go instead with media type versioning and content negotiation (see above).


## Deprecation

From time to time parts of the API (e.g. fields, endpoints, versions) are no longer supported, and for good reason.
However, this may break clients and thus generally is not allowed (see [Don't Break Backward Compatibility](#chapter_dont_break_backward_compatibility)).
For these cases the following deprecation rules have to be applied.

### `MUST` Reflect Deprecation in API Definition

As we do not proactively ask the customers using the API to update their clients to a version that does not use deprecated parts of the API,
we must provide information about planned deprecations.

Each deprecation has to be documented in the API definition:
* The reason for deprecation.
* The time span for how long the functionality is still maintained
* The alternatives (if available).

### `MUST` Monitor Usage of Deprecated Parts of the API

In order to increase customer experience, we monitor the usage of the API.
This is also useful to estimate, what percentage of our customers are still using deprecated parts and hence planning future deprecations.

### `SHOULD` Add a Warning Header to Responses

Whenever a deprecated endpoint is being used or a deprecated field is included in the response,
a `Warning` header ([RFC 7234](https://tools.ietf.org/html/rfc7234#section-5.5)) has to be added in the response,
the `warn-code` must be `299`and the `warn-text` should be in the form of *"The path/operation/parameter/... {name} is deprecated and will be removed by {date}.
Please see {link} for details."* (where the link points to the corresponding deprecation information in the API definition).

### `SHOULD` Add Monitoring for Warning Header

API clients should watch out for `Warning` headers in API responses.

### `MUST` Not Start Using Deprecated APIs

API clients must not start using deprecated parts of the API and should as soon as feasable migrate to using an alternative.


## JSON Guidelines

The JSON guidelines outline the usage of JSON (as defined in [RFC 7159](https://tools.ietf.org/html/rfc7159))

### `MUST` Property Names Must be ASCII `camelCase` (and never `snake_case`): `^[a-z_][a-zA-Z]*$`<a name="chapter_property_names_must_be_ascii"></a>

Property names are restricted to latin letters (`u+0041` through `u+005a` and `u+0061` through `u+007a`) and must start with a lower-case letter or an underscore.
It is recommended to use the underscore as first character only for keywords like `_links`.

We at FLOWFACT think that it helps with development and maintenance if we use the same naming with the property names as with the variable names in our sourcecode.

### `SHOULD` Define Maps Using `additionalProperties`

A "map" here is a dictionary of key-value pairs, where each key appears at most once mapping from string keys to objects of arbitrary type.
In OpenAPI schema (as well as in JSON schema) maps should be represented using `additionalProperties` with a schema defining the value type.
Such an object should normally have no other defined properties.
The keys also must follow the guideline [`MUST` Property Names Must be ASCII `camelCase`](#chapter_property_names_must_be_ascii)

### `MUST` Array Names Should be Pluralized

Arrays naturally contain more than one element and thus its name should indicate that.

### `MUST` Boolean Property Values Must not be Null

A boolean value has binary state and is essentially a closed enumeration of two values, `true` and `false`.
However, there are cases where a third state is meaningful.
In those cases you must resort to an enumeration (e.g. `accepted_terms_and_condition` ∈ {`yes`, `no`, `unknown`} instead of {`true`, `false`})

### `SHOULD` Null Values Should Have Their Fields Removed

Depending on the case having a key with `null` value or omitting it can have different meaning (e.g. JSON Merge Patch).
In all other cases keys with `null` values should be omitted.

This also conforms with OpenAPI, which doesn't support `null` field values but allows optional fields to be omitted.

### `SHOULD` Empty Array Values Should not be Null

Empty array values can unambiguously be represented as the empty list.

### `SHOULD` Enumerations Should be Represented as Strings

Strings are a reasonable target for values that are by design enumerations.

### `SHOULD` Date Property Values Should Conform to RFC 3339

Use the date and time formats defined by [RFC 3339](https://tools.ietf.org/html/rfc3339):
* for date values use strings matching `yyyy-mm-dd` (e.g. `1999-12-31`)
* for date-time values use strings matching `HH-MM-SS` (e.g. `1999-12-31T23:59:59Z`)

A zone offset may be used (both, in request and responses).
However, we encourage restricting dates to UTC and without offsets.
For example 1999-12-31T23:59:59Z rather than 2000-01-01T01:29:59+01:30.

Localization of dates should be done by the services that provide user interfaces, if required.

Sometimes it can seem date values are naturally represented using numerical timestamps,
but this can introduce interpretation issues with precision −
for example whether to represent a timestamp as 1460062925, 1460062925000 or 1460062925.000.
Date strings, though more verbose and requiring more effort to parse, avoid this ambiguity.

### `MAY` Time Durations and Intervals Could Conform to ISO 8601

JSON properties which are by design durations and intervals could be strings formatted as recommended by `ISO 8601` ([Appendix A of RFC 3339](https://tools.ietf.org/html/rfc3339#appendix-A) contains a grammar for durations).

### `MAY` Standards Could be Used for Language, Country and Currency

* [ISO 639-1 language code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes)
* [ISO 3166-1-alpha2 country](http://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) (it's "GB", not "UK")
* a combination of the former two (language and country code) separated by an underscore (e.g. `de_AT`)
* [ISO 4217 currency codes](http://en.wikipedia.org/wiki/ISO_4217)


## API Naming

### `MUST` Use Lowercase Separate Words with Hyphens for Path Segments

Example:
```
/shipment-orders/{shipment_order_id}
```
In the example you can see that this guideline only applies to the path element and not the par parameter.

### `MUST` Use `snake_case` (never `camelCase`) for Query Parameters

Example:
```
/shipment-orders/?include_archived
```

### `SHOULD` Prefer Hyphenated-Pascal-Case for HTTP Header Fields

Most other headers follow this convention.
Avoid camelCase (without hyphens).
Exceptions are common abbreviations like "`ID`".

Examples:
```
Reply-To
Request-ID
```

### `MUST` Pluralize Resource Names

Resources usually provide access to a collection of entities and this must be reflected in their resource names.

### `MUST` Not Use /api as Base Path

Public resources should be made available under the root "`/`" base path.

For Internal resources the base path has to be prefixed by "`/internal`".

For both types of resources two different API specifications and API audiences have to be maintained.

### `MUST` Avoid Trailing Slashes

The trailing slash must not have specific semantics.
Resource paths must deliver the same results whether they have the trailing slash or not.

### `Must` Stick to Conventional Query Parameters<a name="chapter_stick_to_conventional_query_parameters"></a>

If you provide query support for searching, sorting, filtering, and paginating, you must stick to the following naming conventions:
* `q` — default query parameter (e.g. used by browser tab completion)
* `sort` — comma-separated (as defined in [Define Collection Format of Query Parameters and Headers](#chapter_define_collection_format_of_query_parameters_and_headers)) list of fields to define the sort order.
   To indicate sorting direction, fields may be prefixed with `+` (ascending) or `-` (descending), e.g. `/sales-orders?sort=+id`
* `fields` — to retrieve only a subset of fields of a resource. See Should: Support Partial Responses
via Filtering below.
* `embed` — to expand or embedded sub-entities (ie.: inside of an article entity, expand silhouette code into the silhouette object). Implementing embed correctly is difficult, so do it with care.
  See [Allow Optional Embedding of Sub-Resources](#chapter_allow_optional_embedding_of_subresources).
* `offset` — numeric offset of the first element on a page.
  See [Pagination](#chapter_pagination) section.
* `cursor` — an opaque pointer to a page, never to be inspected/constructed by clients.
  It usually (encrypted) encodes the identifier of the first or last page element, the pagination direction,
  and the applied query filters to recreate the collection.
  See [Pagination](#chapter_pagination) section.
* `limit` — client suggested limit to restrict the number of entries on a page.
  See [Pagination](#chapter_pagination) section.

### `MUST` Avoid Actions — Think About Resources

REST is all about your resources, so consider the domain entities that take part in web service interaction,
and aim to model your API around these using the standard HTTP methods as operation indicators.
For instance, if an application has to lock articles explicitly so that only one user may edit them,
create an article lock with PUT or POST instead of using a lock action.

Request:
```
PUT /article-locks/{article-id}
```
The added benefit is that you already have a service for browsing and filtering article locks.

### `SHOULD` Model Complete Business Processes

An API should contain the complete business processes containing all resources representing the process.
This enables clients to understand the business process, foster a consistent design of the business process,
allow for synergies from description and implementation perspective,
and eliminates implicit invisible dependencies between APIs.

In addition, it prevents services from being designed as thin wrappers around databases,
which normally tends to shift business logic to the clients.

### `SHOULD` Define *Useful* Resources

As a rule of thumb resources should be defined to cover 90% of all its client's use cases.
A useful resource should contain as much information as necessary, but as little as possible.
A great way to support the last 10% is to allow clients to specify their needs for more/less information by supporting filtering and [embedding](#chapter_support_partial_responses_via_filtering).

### `MUST` Keep URLs Verb-Free

A REST API is all about resources.
So the only place where actions should appear is in the HTTP methods.
For you it means to use only nouns. Instead of thinking of actions (verbs),
it's often helpful to think about putting a message in a letter box: e.g., instead of having the verb cancel in the url,
think of sending a message to cancel an order to the cancellations letter box on the server side.

### `MUST` Use Domain-Specific Resource Names

API resources represent elements of the application's domain model.
Using domain-specific nomenclature for resource names helps developers to understand the functionality and basic semantics of your resources.
It also reduces the need for further documentation outside the API definition.
For example, "`sales-order-items`" is superior to "order-items" in that it clearly indicates which business object it represents.
Along these lines, "`items`" is too general.

### `MUST` Use URL-friendly Resource Names and Identifiers: [a-zA-Z0-9._-]*

Restricting the pool of allowed characters to ASCII letters, digits, period, underscore, and hyphen (minus) simplifies encoding and support.

### `MUST` Identify Resources and Sub-Resources via Path Segments

Some API resources may contain or reference sub-resources.
Embedded sub-resources, which are not top-level resources,
are parts of a higher-level resource and cannot be used outside of its scope.
Sub-resources should be referenced by their name and identifier in the path segments.

Composite identifiers must not contain / as a separator.
In order to improve the consumer experience, you should aim for intuitively understandable URLs,
where each sub-path is a valid reference to a resource or a set of resources.
For example, if `/customers/12ev123bv12v/addresses/DE_100100101` is a valid path of your API,
then `/customers/12ev123bv12v/addresses, /customers/12ev123bv12v` and `/customers` must be valid as well in principle.

Basic URL structure:
```
/{resources}/[resource-id]/{sub-resources}/[sub-resource-id]
/{resources}/[partial-id-1][separator][partial-id-2]
```
Examples:
```
/carts/1681e6b88ec1/items
/carts/1681e6b88ec1/items/1
/customers/12ev123bv12v/addresses/DE_100100101
/content/images/9cacb4d
```

### `SHOULD` Only Use UUIDs If Necessary

Generating IDs can be a scaling problem in high frequency and near real time use cases.
UUIDs solve this problem, as they can be generated without collisions in a distributed,
non-coordinated way and without additional server round trips.

However, they also come with some disadvantages:
* pure technical key without meaning;
  not ready for naming or name scope conventions that might be helpful for pragmatic reasons,
  e.g. we learned to use names for product attributes, instead of UUIDs
* less usable, because...
  * cannot be memorized and easily communicated by humans
  * harder to use in debugging and logging analysis
  * less convenient for consumer facing usage
  * quite long: readable representation requires 36 characters
  * not ordered along their creation history and no indication of used ID volume
  * may be in conflict with additional backward compatibility support of legacy ids

UUIDs should be avoided when not needed for large scale ID generation.
Instead, for instance, server side support with ID generation can be preferred (POST on ID resource,
followed by idempotent PUT on entity resource).
Usage of UUIDs is especially discouraged as primary keys of master and configuration data,
like brand-IDs or attribute-IDs which have <u>low ID volume but widespread steering functionality</u>.

Please be aware that sequential, strictly monotonically increasing numeric identifiers may reveal critical,
confidential business information, like order volume, to non-privileged clients.

In any case, we should always use string rather than number type for identifiers.
This gives us more flexibility to evolve the identifier naming scheme. Accordingly,
if used as identifiers, UUIDs should not be qualified using a format property.

**Hint:** Usually, random UUID is used − see UUID version 4 in [RFC 4122](https://tools.ietf.org/html/rfc4122).
Though UUID version 1 also contains leading timestamps it is not reflected by its lexicographic sorting.
This deficit is addressed by [ULID](https://github.com/alizain/ulid) (Universally Unique Lexicographically Sortable Identifier).
You may favour ULID instead of UUID, for instance, for pagination use cases ordered along creation time.

### `MAY` Consider Using (Non-) Nested URLs

If a sub-resource is only accessible via its parent resource and may not exists without parent resource,
consider using a nested URL structure, for instance:
```
/carts/1681e6b88ec1/cart-items/1
```
However, if the resource can be accessed directly via its unique ID,
then the API should expose it as a top-level resource.
For example, customer has a collection for sales orders;
however, sales orders have globally unique ID and some services may choose to access the orders directly, for instance:
```
/customers/1681e6b88ec1
/sales-orders/5273gh3k525a
```

### `SHOULD` Limit Number of Resource Types

To keep maintenance and service evolution manageable,
we should follow "functional segmentation" and "[separation of concern](https://en.wikipedia.org/wiki/Separation_of_concerns)" design principles and do not mix different business functionalities.
In practice this means that the number of resource types exposed via an API should be limited.
In this context a resource type is defined as a set of highly related resources such as a collection,
its members and any direct sub-resources.

For example, the resources below would be counted as three resource types, one for customers, one
for the addresses, and one for the customers' related addresses:
```
/customers
/customers/{id}
/customers/{id}/preferences
/customers/{id}/addresses
/customers/{id}/addresses/{addr}
/addresses
/addresses/{addr}
```
Note that:
* We consider `/customers/{id}/preferences` part of the `/customers` resource type because it has a one-to-one relation to the customer without an additional identifier.
* We consider `/customers` and `/customers/{id}/addresses` as separate resource types because `/customers/{id}/addresses/{addr}` also exists with an additional identifier for the address.
* We consider /addresses and /customers/{id}/addresses as separate resource types because there's no reliable way to be sure they are the same.

Given this definition, our experience is that well defined APIs involve no more than 4 to 8 resource
types. There may be exceptions with more complex business domains that require more resources,
but you should first check if you can split them into separate subdomains with distinct APIs.

Nevertheless one API should hold all necessary resources to model complete business processes
helping clients to understand these flows.

### `SHOULD` Limit Number of Sub-Resource Levels

Use sub-resources (or *nested* resources with non-root URLs paths) if their life cycle is (loosely) coupled to the main resource,
i.e. the main resource works as collection resource of the sub-resource entities.
You should use no more than three sub-resource (nesting) levels to restrict the API complexity and url path length.
Note that some popular web browsers do not support URLs of more than 2000 characters.


## HTTP Requests

### `MUST` Use HTTP Methods Correctly

Be compliant with the standardized HTTP method semantics summarized as follows:

#### GET

`GET` requests are used to read either a single or a collection resource.
* `GET` requests for individual resources are to return [`404`](#status_code_404) if the resource does not exist
* `GET` requests for collection resources are to return either [`200`](#status_code_200) (if the collection is empty) or [`404`](#status_code_404) (if the collection is missing)
* `GET` requests must NOT have a request body payload (see [GET With Body](#chapter_get_with_body))

**Note:** `GET` requests on collection resources should provide sufficient [filter](#chapter_stick_to_conventional_query_parameters) and [pagination](#chapter_pagination) mechanisms.

#### GET with Body<a name="chapter_get_with_body"></a>

On occasions an endpoint has to receive extensive structured request information with `GET`,
that may conflict with the URL size limits of clients, load balancers, and servers.
As we require the body in `GET` to be ignored on server side,
you have to check the following two options:
1. `GET` with URL encoded query parameters:
   your first choice should be encoding the request information in query parameters (respecting the usual size limits of clients, gateways, and servers) if possible.
2. `POST` with body content:
   when your first choice is not possible, a `POST` with body content must be used.
   In this case the endpoint must be documented with the hint [GET With Body](#chapter_get_with_body) to transport the `GET` semantic of this call.

**Note:** Refrain from encoding the lengthy structured request information in header parameters.
By design a REST operation is semantically speaking comprised of just the URL and body.
Request headers on the other hand are reserved for general context information.
In addition, size limits on query parameters and headers are not reliable and depend on clients,
gateways, server, and actual settings.
Thus, switching to headers does not solve the original problem.

#### PUT

`PUT` requests are used to update (in rare cases to create) entire resources – single or collection resources.
The semantic is best described as *"please put the enclosed representation at the resource mentioned by the URL, replacing any existing resource."*.
* `PUT` requests are usually applied to single resources, and not to collection resources,
  as this would imply replacing the entire collection
* `PUT` requests are usually robust against non-existence of resources by implicitly creating before updating
* on successful `PUT` requests, the server will replace the entire resource addressed by the URL with the representation passed in the payload (subsequent reads will deliver the same payload)
* successful PUT requests will usually generate [`200`](#status_code_200) or [`204`](#status_code_204) (if the resource was updated – with or without actual content returned), and [`201`](#status_code_201) (if the resource was created)

**Important:** It is best practice to prefer `POST` over `PUT` for creation of (at least top-level) resources.
This leaves the resource ID under control of the service and allows to concentrate on the update semantic using `PUT` as follows.

**Note:** In the rare cases where `PUT` is although used for resource creation, the resource IDs are maintained by the client and passed as a URL path segment.
Putting the same resource twice is required to be idempotent and to result in the same single resource instance (see [Fulfill Common Method Properties](#chapter_fulfill_common_method_properties)).

**Hint:** To prevent unnoticed concurrent updates and duplicate creations when using `PUT`,
you may [Consider to Support ETag Together With If-Match/If-None-Match Header](#chapter_consider_to_support_etag_together_with_if_match_if_none_match_header) to allow the server to react on stricter demands that expose conflicts and prevent lost updates.
See also [Optimistic Locking in RESTful APIs](#optimistic_locking_in_a_restful_api) for details and options.

#### POST

`POST` requests are idiomatically used to create single resources on a collection resource endpoint,
but other semantics on single resources endpoint are equally possible.
The semantic for collection endpoints is best described as *"please add the enclosed representation to the collection resource identified by the URL"*.
* on a successful POST request, the server will create one or multiple new resources and provide their URI/URLs in the response
* successful POST requests will usually generate [`200`](#status_code_200) (if resources have been updated),
  [`201`](#status_code_201) (if resources have been created),
  [`202`](#status_code_202) (if the request was accepted but has not been finished yet),
  and exceptionally [`204`](#status_code_204) with `Location` header (if the actual resource is not returned).

The semantic for single resource endpoints is best described as *"please execute the given well specified request on the resource identified by the URL"*.

**Generally:** `POST` should be used for scenarios that cannot be covered by the other methods sufficiently.
In such cases, make sure to document the fact that `POST` is used as a workaround (see [GET With Body](#chapter_get_with_body)).

**Note:** Resource IDs with respect to `POST` requests are created and maintained by server and returned with response payload.

**Hint:** Posting the same resource twice is not required to be idempotent (check [Fulfill Common Method Properties](#chapter_fulfill_common_method_properties)) and may result in multiple resources.
However, you should [Consider to Design POST and PATCH Idempotent](#chapter_consider_to_design_post_and_patch_idempotent) to prevent this.

#### PATCH
`PATCH` requests are used to update parts of single resources, i.e. where only a specific subset of resource fields should be replaced.
The semantic is best described as "please change the resource identified by the URL according to my change request".
The semantic of the change request is not defined in the HTTP standard and must be described in the API specification by using suitable media types.
* PATCH requests are usually applied to single resources as patching entire collection is challenging
* PATCH requests are usually not robust against non-existence of resource instances
* on successful PATCH requests, the server will update parts of the resource addressed by the URL as defined by the change request in the payload
• successful PATCH requests will usually generate [`200`](#status_code_200) or [`204`](#status_code_204) (if resources have been updated with or without updated content returned)

**Note:** since implementing `PATCH` correctly is a bit tricky, we strongly suggest to choose one and only one of the following patterns per endpoint, unless forced by a [backwards compatible change](#chapter_dont_break_backward_compatibility).
In preference order:
1. use `PUT` with complete objects to update a resource as long as feasible (i.e. do not use `PATCH` at all).
2. use `PATCH` with partial objects to only update parts of a resource, whenever possible.
   (This is basically [JSON Merge Patch](https://tools.ietf.org/html/rfc7396), a specialized media type `application/merge-patch+json` that is a partial resource representation.)
3. use `PATCH` with [JSON Patch](http://tools.ietf.org/html/rfc6902), a specialized media type `application/json-patch+json` that includes instructions on how to change the resource.
4. use `POST` (with a proper description of what is happening) instead of `PATCH`,
   if the request does not modify the resource in a way defined by the semantics of the media type.

In practice [JSON Merge Patch](https://tools.ietf.org/html/rfc7396) quickly turns out to be too limited,
especially when trying to update single objects in large collections (as part of the resource).
In this cases [JSON Patch](http://tools.ietf.org/html/rfc6902) can shown its full power while still showing readable patch requests (see also [JSON patch vs. merge](http://erosb.github.io/post/json-patch-vs-merge-patch)).

**Note:** Patching the same resource twice is **not** required to be idempotent (check [Fulfill Common Method Properties](#chapter_fulfill_common_method_properties)) and may result in a changing result.
However, you should [Consider to Design POST and PATCH Idempotent](#chapter_consider_to_design_post_and_patch_idempotent) to prevent this.

**Hint:** To prevent unnoticed concurrent updates when using `PATCH`, [Consider to Support ETag Together With If-Match/If-None-Match Header](#chapter_consider_to_support_etag_together_with_if_match_if_none_match_header) to allow the server to react on stricter demands that expose conflicts and prevent lost updates.
See [Optimistic Locking in RESTful APIs](#optimistic_locking_in_a_restful_api) and [Consider To Design POST and PATCH Idempotent](#chapter_consider_to_design_post_and_patch_idempotent) for details and options.

#### DELETE

`DELETE` requests are used to delete resources.
The semantic is best described as *"please delete the resource identified by the URL"*.
* `DELETE` requests are usually applied to single resources, not on collection resources,
  as this would imply deleting the entire collection.
* successful `DELETE` requests will usually generate [`200`](#status_code_200) (if the deleted resource is returned) or [`204`](#status_code_204) (if no content is returned)
* failed DELETE requests will usually generate [`404`](#status_code_404) (if the resource cannot be found) or [`410`](#status_code_410) (if the resource was already deleted before).

**Important:** After deleting a resource with DELETE, a GET request on the resource is expected to either return [`404`](#status_code_404) (not found) or 410 (gone) depending on how the resource is represented after deletion.
Under no circumstances the resource must be accessible after this operation on its endpoint.

#### HEAD

`HEAD` requests are used to retrieve the header information of single resources and resource collections.
* `HEAD` has exactly the same semantics as `GET`, but returns headers only, no body.

**Hint:** `HEAD` is particular useful to efficiently lookup whether large resources or collection resources have been updated in conjunction with the `ETag`-header.

#### OPTIONS
`OPTIONS` requests are used to inspect the available operations (HTTP methods) of a given endpoint.
* `OPTIONS` responses usually either return a comma separated list of methods in the `Allow` header
or as a structured list of link templates

**Note:** `OPTIONS` is rarely implemented, though it could be used to self-describe the full functionality of a resource.

### `MUST` Fulfill Common Method Properties<a name="chapter_fulfill_common_method_properties"></a>

Request methods in RESTful services can be...
* [safe](https://tools.ietf.org/html/rfc7231#section-4.2.1) − the operation semantic is defined to be read-only, meaning it must not have *intended side effects*, i.e. changes, to the server state.
* [idempotent](https://tools.ietf.org/html/rfc7231#section-4.2.2) − the operation has the same *intended effect* on the server state, independently whether it is executed once or multiple times.
  **Note:** this does not require that the operation is returning the same response or status code.
* [cache-able](https://tools.ietf.org/html/rfc7231#section-4.2.3)<a name="bulletpoint_idempotent_http_method"></a> − to indicate that responses are allowed to be stored for future reuse.
  In general, requests to safe methods are cache-able, if it does not require a current or authoritative response
from the server.

**Note:** The above definitions, of *intended (side) effect* allows the server to provide additional state changing behavior as logging, accounting, pre-fetching, etc.
However, these actual effects and state changes, must not be intended by the operation so that it can be held accountable.

Method implementations must fulfill the following basic properties according to [RFC 7231](https://tools.ietf.org/html/rfc7231):

Method | Safe | Idempotent | Cache-able
---:|:---:|:---:|:---:
`GET` | Yes | Yes | Yes
`HEAD` | Yes | Yes | Yes
`POST` | No | No, but [Consider To Design POST and PATCH Idempotent](#chapter_consider_to_design_post_and_patch_idempotent) | May, but only if specific `POST` endpoint is *safe*<br></br>**Hint:** not supported by most caches.
`PUT` | No | Yes | No
`PATCH` | No | No, but [Consider To Design POST and PATCH Idempotent](#chapter_consider_to_design_post_and_patch_idempotent) | No

**Note:** [Document Cache-able GET, HEAD, and POST Endpoints](#document_cacheable_get_head_and_post_endpoints).

### `SHOULD` Consider to Design POST and PATCH Idempotent<a name="chapter_consider_to_design_post_and_patch_idempotent"></a>

In many cases it is helpful or even necessary to design `POST` and `PATCH` idempotent for clients to expose conflicts and prevent resource duplicate (a.k.a. zombie resources) or lost updates,
e.g. if same resources may be created or changed in parallel or multiple times.
To design an idempotent API endpoint owners should consider to apply one of the following three patterns.
* A resource specific **conditional key** provided via `If-Match` header in the request.
  The key is in general a meta information of the resource, e.g. a *hash* or *version number*, often stored with it.
  It allows to detect concurrent creations and updates to ensure [idempotent](#bulletpoint_idempotent_http_method) behavior (see [Consider to Support ETag Together With If-Match/If-None-Match Header](#chapter_consider_to_support_etag_together_with_if_match_if_none_match_header)).
* A resource specific **secondary key** provided as resource property in the request body.
  The *secondary key* is stored permanently in the resource.
  It allows to ensure idempotent behavior by looking up the unique secondary key in case of multiple independent resource creations from different clients (see [Use Secondary Key for Idempotent POST Design](#use_secondary_key_for_idempotent_post_design)).
• A client specific **idempotency key** provided via `Idempotency-Key` header in the request.
  The key is not part of the resource but stored temporarily pointing to the original response to ensure [idempotent](#bulletpoint_idempotent_http_method) behavior when retrying a request (see [Consider to Support Idempotency-Key Header](#consider_to_support_idempotency_key_header)).

**Note:** While **conditional key** and **secondary key** are focused on handling concurrent requests,
the **idempotency key** is focused on providing the exact same responses,
which is even a stronger requirement than the [idempotency](#bulletpoint_idempotent_http_method) defined above.
It can be combined with the two other patterns.

To decide, which pattern is suitable for your use case,
please consult the following table showing the major properties of each pattern:

| | Conditional Key | Secondary Key | Idempotency Key
--- |:---:|:---:|:---:
Applicable with … | `PATCH` | `POST` | `POST`/`PATCH`
HTTP Standard | Yes | No | No
Prevents duplicate (zombie) resources | Yes | Yes | No
Prevents concurrent lost updates | Yes | No | No
Supports safe retries | Yes | No | No
Supports exact same response | Yes | Yes | Yes
Can be inspected (by intermediaries) | Yes | No | Yes
Usable without previous `GET` | No | Yes | Yes

**Note:** The patterns applicable to `PATCH` can be applied in the same way to `PUT` and `DELETE` providing the same properties.

If you mainly aim to support safe retries, we suggest to apply [conditional key](#chapter_consider_to_support_etag_together_with_if_match_if_none_match_header) and [secondary key](#use_secondary_key_for_idempotent_post_design) pattern before the [Idempotency Key](#consider_to_support_idempotency_key_header) pattern.

### `SHOULD` Use Secondary Key for Idempotent POST Design<a name="use_secondary_key_for_idempotent_post_design"></a>

The most important pattern to design `POST` [idempotent](#bulletpoint_idempotent_http_method) for creation is to introduce a resource specific **secondary key** provided in the request body,
to eliminate the problem of duplicate (a.k.a zombie) resources.

The secondary key is stored permanently in the resource as *alternate key* or *combined key* (if consisting of multiple properties) guarded by a uniqueness constraint enforced server-side,
that is visible when reading the resource.
The best and often naturally existing candidate is a *unique foreign key*,
that points to another resource having *one-on-one* relationship with the newly created resource, e.g. a parent process identifier.

A good example here for a secondary key is the shopping cart ID in an order resource.

**Note:** When using the secondary key pattern without `Idempotency-Key` all subsequent retries should fail with status code [409](#status_code_409).
We suggest to avoid [200](#status_code_200) here unless you make sure, that the delivered resource is the original one implementing a well defined behavior.
Using [204](#status_code_204) without content would be a similar well defined option.

### `SHOULD` Define Collection Format of Query Parameters and Headers<a name="chapter_define_collection_format_of_query_parameters_and_headers"></a>

Sometimes, query parameters and headers allow to provide a list of values, either by providing a comma-separated list (`csv`) or by repeating the parameter multiple times with different values (`multi`).
The API specification should explicitly define one type as follows:

Description | OpenAPI 3.0 | OpenAPI 2.0 | Example
--- | --- | --- | ---
Comma separated values | `style: form,`<br></br>`explode: false` | `collectionFormat: csv` | `?param=value1,value2`
Multiple parameters| `style: form,`<br></br>`explode: true` | `collectionFormat: multi` | `?param=value1&param=value2`

When choosing the collection format, take into account the tool support, the escaping of special
characters and the maximal URL length.

### `MUST` Document Implicit Filtering

Sometimes certain collection resources or queries will not list all the possible elements they have,
but only those for which the current client is authorized to access.
Implicit filtering could be done on:
• the collection of resources being return on a parent `GET` request.
• the fields returned for the resource's detail.

In such cases, the implicit filtering must be in the API specification (in its description).

Consider [caching considerations](#document_cacheable_get_head_and_post_endpoints) when implicitly filtering.


## HTTP Status Codes and Errors

### `MUST` Specify Success and Error Responses

Documenting **all** probable success and error responses is a vital part in defining how an API is used correctly.
This especially includes response codes which convey application-specific functional semantics or are used in a none standard way that requires additional explanation.

For the non-trivial cases you should also think about maintaining a troubleshooting board.
This can reduce service support tasks and contribute to service client and provider performance.

### `MUST` Use Standard HTTP Status Codes

You must only use standardized HTTP status codes consistently with their intended semantics.
You must not invent new HTTP status codes.
RFC standards define about 60 different HTTP status codes with specific semantics (mainly [RFC7231](https://tools.ietf.org/html/rfc7231) and [RFC-6585](https://tools.ietf.org/html/rfc6585) —
and there are upcoming new ones, e.g. draft legally-restricted-status.
See overview on all error codes on [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) or via [https://httpstatuses.com/](https://httpstatuses.com/)) also including 'unofficial codes', e.g. used by popular web servers like Nginx.
Below we list the most commonly used and best understood HTTP status codes, consistent with their semantic in the RFCs.
APIs should only use these to prevent misconceptions that arise from less commonly used HTTP status codes.

**Important:** As long as your HTTP status code usage is well covered by the semantic defined here,
you should not describe it to avoid an overload with common sense information and the risk of inconsistent definitions.
Only if the HTTP status code is not in the list below or its usage requires additional information aside the well defined semantic,
the API specification must provide a clear description of the HTTP status code in the response.

#### Success Codes

Code | Meaning | Methods
:---:| --- | ---
200<a name="status_code_200"></a> | OK − this is the standard success response | *all*
201<a name="status_code_201"></a> | Created − Returned on successful entity creation. You are free to return either an empty response or the created resource in conjunction with the Location header. (More details found in the [Common Headers](#common_headers).) Always set the Location header. | `POST`,&#160;`PUT`
202<a name="status_code_202"></a> | Accepted − The request was successful and will be processed asynchronously. | `POST`,&#160;`PUT`,&#160;`PATCH`,&#160;`DELETE`
204<a name="status_code_204"></a> | No content − There is no response body. | `PUT`,&#160;`PATCH`,&#160;`DELETE`
207<a name="status_code_207"></a> | Multi-Status − The response body contains multiple status information for different parts of a batch/bulk request (see [Use Code 207 for Batch or Bulk Requests](#use_code_207_for_batch_or_bulk_requests)). | `POST`

#### Redirection Codes
Code | Meaning | Methods
:---:| --- | ---
301<a name="status_code_301"></a> | Moved Permanently − This and all future requests should be directed to the given URI. | *all*
301<a name="status_code_301"></a> | See Other − The response to the request can be found under another URI using a GET method. | `POST`,&#160;`PUT`,&#160;`PATCH`,&#160;`DELETE`
304<a name="status_code_304"></a> | Not Modified − resource has not been modified since the date or version passed via request headers `If-Modified-Since` or `If-None-Match`. | `GET`

#### Client Side Error Codes<a name="chapter_status_codes_4xx"></a>
Code | Meaning | Methods
:---:| --- | ---
400<a name="status_code_400"></a> | Bad request − generic / unknown error. Should also be delivered in case of input payload fails business logic validation. | *all*
401<a name="status_code_401"></a> | Unauthorized − the users must log in (this often means "Unauthenticated"). | *all*
403<a name="status_code_403"></a> | Forbidden − the user is not authorized to use this resource. | *all*
404<a name="status_code_404"></a> | Not found − the resource is not found. | *all*
405<a name="status_code_405"></a> | Method Not Allowed − the method is not supported, see `OPTIONS`. | *all*
405<a name="status_code_405"></a> | Not Acceptable − resource can only generate content not acceptable according to the Accept headers sent in the request. | *all*
408<a name="status_code_408"></a> | Request timeout − the server times out waiting for the resource. | *all*
409<a name="status_code_409"></a> | Conflict − request cannot be completed due to conflict, e.g. when two clients try to create the same resource or if there are concurrent, conflicting updates. | `POST`,&#160;`PUT`,&#160;`PATCH`,&#160;`DELETE`
410<a name="status_code_410"></a> | Gone − resource does not exist any longer, e.g. when accessing a resource that has intentionally been deleted. | *all*
412<a name="status_code_412"></a> | Precondition Failed − returned for conditional requests, e.g. `If-Match` if the condition failed. Used for optimistic locking. | `PUT`,&#160;`PATCH`,&#160;`DELETE`
415<a name="status_code_415"></a> | Unsupported Media Type − e.g. clients sends request body without content type. | `POST`,&#160;`PUT`,&#160;`PATCH`,&#160;`DELETE`
423<a name="status_code_423"></a> | Locked − Pessimistic locking, e.g. processing states. | `PUT`,&#160;`PATCH`,&#160;`DELETE`
428<a name="status_code_428"></a> | Precondition Required − server requires the request to be conditional, e.g. to make sure that the "lost update problem" is avoided (see [Consider to Support Prefer Header to Handle Processing Preferences](#consider_to_support_prefer_header_to_handle_processing_preferences)). | *all*
429<a name="status_code_429"></a> | Too many requests − the client does not consider rate limiting and sent too many requests (see [Use Code 429 with Headers for Rate Limits](#use_code_429_with_headers_for_rate_limits)). | *all*

#### Server Side Error Codes<a name="chapter_status_codes_5xx"></a>
Code | Meaning | Methods
:---:| --- | ---
500<a name="status_code_500"></a> | Internal Server Error − a generic error indication for an unexpected server execution problem (here, client retry may be sensible) | *all*
501<a name="status_code_501"></a> | Not Implemented − server cannot fulfill the request (usually implies future availability, e.g. new feature). | *all*
503<a name="status_code_503"></a> | Service Unavailable − service is (temporarily) not available (e.g. if a required component or downstream service is not available) — client retry may be sensible. If possible, the service should indicate how long the client should wait by setting the `Retry-After` header. | *all*

### `MUST` Use Most Specific HTTP Status Codes

You must use the most specific HTTP status code when returning information about your request processing status or error situations.

### `MUST` Use Code 207 for Batch or Bulk Requests<a name="use_code_207_for_batch_or_bulk_requests"></a>

Some APIs are required to provide either *batch* or *bulk* requests using `POST` for performance reasons,
i.e. for communication and processing efficiency.
In this case services may be in need to signal multiple response codes for each part of an batch or bulk request.
As HTTP does not provide proper guidance for handling batch/bulk requests and responses,
we herewith define the following approach:
* A batch or bulk request **always** has to respond with HTTP status code [207](#status_code_207),
  unless it encounters a generic or unexpected failure before looking at individual parts.
* A batch or bulk response with status code [207](#status_code_207) **always** returns a multi-status object containing sufficient status and/or monitoring information for each part of the batch or bulk request.
* A batch or bulk request may result in a status code [4xx](#chapter_status_codes_4xx)[5xx](#chapter_status_codes_5xx),
  only if the service encounters a failure before looking at individual parts or, if an unanticipated failure occurs.

The before rules apply *even in the case* that processing of all individual part *fail* or each part is executed *asynchronously*!
They are intended to allow clients to act on batch and bulk responses by inspecting the individual results in a consistent way.

**Note:** while a *batch* defines a collection of requests triggering independent processes,
a *bulk* defines a collection of independent resources created or updated together in one request.
With respect to response processing this distinction normally does not matter.

### `MUST` Use Code 429 with Headers for Rate Limits<a name="use_code_429_with_headers_for_rate_limits"></a>

APIs that wish to manage the request rate of clients must use the [429](#status_code_429) response code,
if the client exceeded the request rate (see [RFC 6585](https://tools.ietf.org/html/rfc6585)).
Such responses must also contain header information providing further details to the client.
There are two approaches a service can take for header information:
* Return a `Retry-After` header indicating how long the client ought to wait before making a follow-up request.
The `Retry-After` header can contain a HTTP date value to retry after or the number of seconds to delay.
Either is acceptable but APIs should prefer to use a delay in seconds.
* Return a trio of `X-RateLimit` headers.
These headers (described below) allow a server to express a service level in the form of a number of allowing requests within a given window of time and when the window is reset.

The `X-RateLimit` headers are:
* `X-RateLimit-Limit`: The maximum number of requests that the client is allowed to make in this
window.
* `X-RateLimit-Remaining`: The number of requests allowed in the current window.
* `X-RateLimit-Reset`: The relative time in seconds when the rate limit window will be reset.
  **Beware** that this is different to Github and Twitter’s usage of a header with the same name which is using UTC epoch seconds instead.

The reason to allow both approaches is that APIs can have different needs.
`Retry-After` is often sufficient for general load handling and request throttling scenarios and notably,
does not strictly require the concept of a calling entity such as a tenant or named account.
In turn this allows resource owners to minimise the amount of state they have to carry with respect to client requests.
The `X-RateLimit` headers are suitable for scenarios where clients are associated with pre-existing account or tenancy structures.
`X-RateLimit` headers are generally returned on every request and not just on a [429](#status_code_429),
which implies the service implementing the API is carrying sufficient state to track the number of requests made within a given window for each named entity.

### `MUST` Use Problem JSON

[RFC 7807](https://tools.ietf.org/html/rfc7807) defines a Problem JSON object and the media type `application/problem+json`.
Operations should return it (together with a suitable status code) when any problem occurred during processing and you can give more details than the status code itself can supply,
whether it be caused by the client or the server (i.e. both for [4xx](#chapter_status_codes_4xx) or [5xx](#chapter_status_codes_5xx) error codes).

You may define custom problem types as extension of the Problem JSON object if you need to return specific additional error detail information.

**Hint** for backward compatibility: A previous version of this guideline (before the publication of [RFC 7807](https://tools.ietf.org/html/rfc7807) and the registration of the media type) told to return custom variant of the media type `application/x.problem+json`.
Servers for APIs defined before this change should pay attention to the `Accept` header sent by the client and set the `Content-Type` header of the problem response correspondingly.
Clients of the API should accept both media types.

### `MUST` Do not Expose Stack Traces

Stack traces contain implementation details that are not part of an API,
and on which clients should never rely.
Moreover, stack traces can leak sensitive information that partners and third parties are not allowed to receive and may disclose insights about vulnerabilities to attackers.


## Performance

TODO

### `SHOULD` Reduce Bandwidth Needs and Improve Responsiveness

TODO

### `SHOULD` Use gzip Compression

TODO

### `SHOULD` Support Partial Responses via Filtering<a name="chapter_support_partial_responses_via_filtering"></a>

TODO

### `SHOULD` Allow Optional Embedding of Sub-Resources<a name="chapter_allow_optional_embedding_of_subresources"></a>

TODO

### `MUST` Document Cache-able GET, HEAD, and POST Endpoints<a name="document_cacheable_get_head_and_post_endpoints"></a>

TODO


## Pagination<a name="chapter_pagination"></a>

TODO


## Hypermedia

TODO

### `MUST` Use REST Maturity Level 2

TODO

### `MAY` Use REST Maturity Level 3 − HATEOAS

TODO

### `MUST` Use Full, Absolute URI

TODO

### `MUST` Use Common Hypertext Controls

TODO

### `SHOULD` Use Simple Hypertext Controls for Pagination and Self-References

TODO

### `MUST` Not Use Link Headers with JSON Entities

TODO


## Data Formats

TODO

### `MUST` Use JSON to Encode Structured Data

TODO

### `MAY` Use non-JSON Media Types for Binary Data or Alternative Content Representations

TODO

### `SHOULD` Prefer Standard Media Type Name `application/json`

TODO

### `MUST` Use Standard Date and Time Formats

TODO

### `MAY` Use Standards for Country, Language and Currency Codes

TODO

### `MUST` Define Format for Type Number and Integer TODO


## Common Data Types

TODO

### `SHOULD` Use a Common Money Object

TODO

### `MUST` Use Common Field Names and Semantics TODO


## Common Headers<a name="common_headers"></a>

TODO

### `MUST` Use Content-* Headers Correctly

TODO

### `MAY` Use Standardized Headers

TODO

### `MAY` Use Content-Location Header

TODO

### `SHOULD` Use Location Header Instead of Content-Location Header

TODO

### `MAY` Consider to Support Prefer Header to Handle Processing Preferences<a name="consider_to_support_prefer_header_to_handle_processing_preferences"></a>

TODO

### `MAY` Consider to Support ETag Together With If-Match/If-None-Match Header<a name="chapter_consider_to_support_etag_together_with_if_match_if_none_match_header"></a>

TODO

### `MAY` Consider to Support Idempotency-Key Header<a name="consider_to_support_idempotency_key_header></a>

TODO


## Proprietary Headers

TODO

### `MUST` Use Only the Specified Proprietary Zalando Headers

TODO

### `MUST` Propagate Proprietary Headers TODO


## API Operation

TODO

### `MUST` Publish OpenAPI Specification

TODO

### `SHOULD` Monitor API Usage

TODO

# Appendix A: References

TODO

## OpenAPI Specification

TODO

## Publications, specifications and standards

TODO

## Dissertations

TODO

## Books.

TODO

## Blogs

TODO

# Appendix B: Tooling.

TODO

## API First Integrations

TODO

## Support Libraries

TODO

# Appendix C: Best Practices

TODO

## Optimistic Locking in a RESTful API<a name="optimistic_locking_in_a_restful_api"></a>

TODO

# Appendix D: Changelog.

TODO

## Rule Changes
TODO


# TODO

* Re-phrase the passages copied from other documentation (or cite it).
