FLOWFACT Restful API Guidelines
===============================

TODO


## Introduction

TODO


# Principles

TODO


# Guidelines

The guideline titles are marked with the following labels: `MUST`, `SHOULD`, or `MAY`.
They reflect the requirement of corresponding guideline and is to be interpreted as described in [RFC 2119](https://www.ietf.org/rfc/rfc2119.txt).

TODO

## General Guidelines

### `SHOULD` Follow API First Principle

You must follow the API First Principle, more specifically:
- When implementing a new or modifying an existing REST service or parts of it − thus modifying the API −,
you must obtain approval by review by at least one API expert.
- You must design your APIs consistently with this guidelines.

The review must assert that the modification is consistent with all guidelines in this document.

TODO

### `MUST` Provide API Specification Using OpenAPI

When implementing a new or modifying an existing REST service or parts of it,
annotate it with meaningful [Swagger](https://swagger.io/) documentation.
The documentation must provide sufficient information to enable any developer to use the REST endpoint(s).
For Swagger in particular it must include:
- for each REST controller:
  - `io.swagger.annotations.Api`
- for each REST endpoint:
  - `io.swagger.annotations.ApiOperation`
  - for all probable HTTP response codes:
    - `io.swagger.annotations.ApiResponses`
  - for each parameter:
    - `io.swagger.annotations.ApiParam`
    - for any validation:
      - make sure that all constraints are clearly defined in description
- for each REST model (consumed or produced by an endpoint):
  - `io.swagger.annotations.ApiModel`
    - for each field:
      - `io.swagger.annotations.ApiModelProperty`

### `MUST` Write APIs in U.S. or British English


## Security


### `SHOULD` Secure Endpoints

The API endpoint (with only a few exceptions) needs to be secured by one or more of the following methods:
- [AWS Cognito](https://aws.amazon.com/)
- [BasicAuth](https://en.wikipedia.org/wiki/Basic_access_authentication)

If an API endpoints is destined to be not secure, it must be,
and only be accessible via an absolute REST path starting with `/public/`.


## Compatibility

### `MUST` Don’t Break Backward Compatibility

You may change the API, but keep all customers (API clients) running.
Keep in mind that the API is a contract between the service provider and service consumer (a.k.a. client).

Whenever changing the API, do it by adding compatible extensions.
In the case that this is not a choice,
introduce a new API version while still supporting older versions.

And we strongly encourage you to refrain to compatible extensions and also discourage versioning.

**Note:**
The following guidelines discuss the various aspects of how to preserve compatiblity.
They however do not cover incompatible changes but only breaking changes.
Breaking changes are incompatible changes deployed into operation,
and thereby breaking the API contract for consumers.
However an incompatible change may not ever be deployed into the production lifecycle.

### `MUST` Prefer Compatible Extensions

With each and every modification, the API should evolve in a backward-compatible way:
- Add only optional, never mandatory fields.
- Never change the semantic of fields (e.g. changing the semantic from entity ID to
entity name)
- Never change the validation logic to be more restrictive.
- Enum ranges:
  - can be reduced when used as input parameters,
    only if the endpoint is ready to accept and handle old range values too.
  - can be reduced when used as output parameters.
  - cannot be extended when used for output parameters — clients may not be prepared to handle it.
    However, enum ranges can be extended when used for input parameters.
- Use `x-extensible-enum`, if range is used for output parameters and likely to be extended with growing functionality.
  It defines an open list of explicit values and clients must be agnostic to new values.
- Support redirection in case an URL has to change `301 - Moved Permanently`.

### `MUST` Prepare Clients To Not Crash On Compatible API Extensions

Clients should apply the [Robustness Principle](https://en.wikipedia.org/wiki/Robustness_principle):
- Be conservative with API requests and data passed as input, e.g. avoid to exploit definition
deficits like passing megabytes of strings with unspecified maximum length.
- Be tolerant in processing and reading data of API responses

Clients must be prepared for compatible API extensions of service providers:
- Be tolerant with unknown fields in the payload (see also [Fowler’s TolerantReader post](https://martinfowler.com/bliki/TolerantReader.html)),
i.e. ignore new fields but do not eliminate them from payload if needed for subsequent `PUT` requests.
- Be prepared that `x-extensible-enum` return parameter may deliver new values;
  either be agnostic or provide default behavior for unknown values.
- Be prepared to handle HTTP status codes not explicitly specified in endpoint definitions.
  Note also, that status codes are extensible.
  Default handling is how you would treat the corresponding code (see [RFC 7231 Section 6](https://www.ietf.org/rfc/rfc7231.txt)).
- Follow the redirect when the server returns HTTP status code `301 - Moved Permanently`.

### `SHOULD` Design APIs Conservatively
The API should be conservative and accurate in what it accepts from clients:
- Unknown input fields in payload or URL should not be ignored;
  servers should provide error feedback to clients via an HTTP `400` response code.
- Be accurate in defining input data constraints (like formats, ranges, lengths etc.) —
  and check constraints and return dedicated error information in case of violations.
- Prefer being more specific and restrictive (if compliant to functional requirements),
  e.g. by defining length range of strings.
  It may simplify implementation while providing freedom for further evolution as compatible extensions.

Not ignoring unknown input fields is a specific deviation from [Postel’s Law](https://en.wikipedia.org/wiki/Robustness_principle) (e.g. see also [The Robustness Principle Reconsidered](https://cacm.acm.org/magazines/2011/8/114933-the-robustness-principle-reconsidered/fulltext)) and a strong recommendation.
The API might want to take a different approach but should be aware of the following problems and be explicit in what is supported:
- Ignoring unknown input fields is actually not an option for `PUT`,
  since it becomes asymmetric with subsequent `GET` response and HTTP is clear about the `PUT` replace semantics and default roundtrip expectations (see [RFC 7231 Section 4.3.4](https://www.ietf.org/rfc/rfc7231.txt)).
  Note, accepting (i.e. not ignoring) unknown input fields and returning it in subsequent `GET` responses is a different situation and compliant to `PUT` semantics.
- Certain client errors cannot be recognized by servers,
  e.g. attribute name typing errors will be ignored without server error feedback.
  The server cannot differentiate between the client intentionally providing an additional field versus the client sending a mistakenly named field,
  when the client’s actual intent was to provide an optional input field.
- Future extensions of the input data structure might be in conflict with already ignored fields and,
  hence, will not be compatible,
  i.e. break clients that already use this field but with different type.

In specific situations, where a (known) input field is not needed anymore,
it either can stay in the API definition with "not used anymore" description or can be removed from the API definition as long as the server ignores this specific parameter.

### `MUST` Always Return JSON Objects As Top-Level Data Structures To Support Extensibility

**Always** return a JSON object (and not e.g. an array) as a top level data structure to support future extensibility.

### `SHOULD` Use Open-Ended List of Values Instead of Enumerations

Enumerations are per definition closed sets of values,
that are assumed to be complete and not intended for extension.
This closed principle of enumerations imposes compatibility issues when an enumeration must be extended.
To avoid these issues, we strongly recommend to use an open-ended list of values instead of an enumeration.

To specify an open-ended list of values use the marker x-extensible-enum as follows:
```
deliver_methods:
  type: string
  x-extensible-enum:
    - parcel
    - letter
    - email
```
**Note:** `x-extensible-enum` is not JSON Schema conform but will be ignored by most tools.

### `SHOULD` Avoid Versioning

Only if the modification cannot absolutely be done in a compatible way,
introduce a new version as it complicates things,
and significantly increases testing, operating, and maintenance efforts.
Proceed in one of these three ways:
- create a new resource (variant) in addition to the old resource variant
- create a new service endpoint — i.e. a new application with a new API (with a new domain name)
- create a new API version supported in parallel with the old API by the same microservice

As we discourage versioning by all means because of the manifold disadvantages,
we strongly recommend to only use the first two approaches.

### `MUST` Use Media Type Versioning

However, when API versioning is unavoidable,
you have to design your multi-version APIs using media type versioning (instead of URI versioning, see below).
Media type versioning is less tightly coupled since it supports content negotiation and hence reduces complexity of release management.

Media type versioning: Here, version information and media type are provided together via the HTTP Content-Type header — e.g. `application/x.flowfact.schema+json;version=2`.
For incompatible changes, a new media type version for the resource is created.
To generate the new representation version,
consumer and producer can do content negotiation using the HTTP `Content-Type` and `Accept` headers.
Note: This versioning only applies to the request and response content schema,
not to URI or method semantics.

In this example, a client wants only the new version of the response:
```
Accept: application/x.flowfact.schema+json;version=2
```
A server responding to this, as well as a client sending a request with content should use the `Content-Type` header, declaring that one is sending the new version:
```
Content-Type: application/x.flowfact.schema+json;version=2
```
Using header versioning should:
- include versions in request and response headers to increase visibility
- include Content-Type in the Vary header to enable proxy caches to differ between versions

**Hint:** Until an incompatible change is necessary, it is recommended to stay with the standard `application/json` media type.

Further reading: [API Versioning Has No "Right Way"](https://blog.apisyouwonthate.com/api-versioning-has-no-right-way-f3c75457c0b7) provides an overview on different versioning approaches to handle breaking changes without being opinionated.

### `MUST` Do Not Use URI Versioning

With URI versioning a (major) version number is included in the path, e.g. `/v1/customers`.
The consumer has to wait until the provider has been released and deployed.
If the consumer also supports hypermedia links — even in their APIs — to drive workflows ([HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)),
this quickly becomes complex.
So does coordinating version upgrades — especially with hyperlinked service dependencies — when using URL versioning.
To avoid this tighter coupling and complexer release management we do not use URI versioning,
and go instead with media type versioning and content negotiation (see above).


## Deprecation

TODO

### `MUST` Reflect Deprecation in API Definition

TODO

### `MUST` Monitor Usage of Deprecated APIs

TODO

### `SHOULD` Add a Warning Header to Responses

TODO

### `SHOULD` Add Monitoring for Warning Header

TODO

### `MUST` Not Start Using Deprecated APIs

TODO


## JSON Guidelines

TODO

### `MUST` Property Names Must be ASCII `snake_case` (and never `camelCase`): `^[a-z_][a-z_0-9]*$`

TODO

### `SHOULD` Define Maps Using `additionalProperties`

TODO

### `MUST` Array Names Should be Pluralized

TODO

### `MUST` Boolean Property Values Must not be Null

TODO

### `SHOULD` Null Values Should Have Their Fields Removed

TODO

### `SHOULD` Empty Array Values Should not be Null

TODO

### `SHOULD` Enumerations Should be Represented as Strings

TODO

### `SHOULD` Date Property Values Should Conform to RFC 3339

TODO

### `MAY` Time Durations and Intervals Could Conform to ISO 8601

TODO

### `MAY` Standards Could be Used for Language, Country and Currency

TODO


## API Naming

TODO

### `MUST` Use Lowercase Separate Words with Hyphens for Path Segments

TODO

### `MUST` Use `snake_case` (never `camelCase`) for Query Parameters

TODO

### `SHOULD` Prefer Hyphenated-Pascal-Case for HTTP Header Fields

TODO

### `MUST` Pluralize Resource Names

TODO

### `MUST` Not Use /api as Base Path

TODO

### `MUST` Avoid Trailing Slashes

TODO

### `MUST` Avoid Actions — Think About Resources

TODO

### `SHOULD` Model Complete Business Processes

TODO

### `SHOULD` Define Useful Resources

TODO

### `MUST` Keep URLs Verb-Free

TODO

### `MUST` Use Domain-Specific Resource Names

TODO

### `MUST` Use URL-friendly Resource Identifiers: [a-zA-Z0-9:._-]*

TODO

### `MUST` Identify Resources and Sub-Resources via Path Segments

TODO

### `SHOULD` Only Use UUIDs If Necessary

TODO

### `MAY` Consider Using (Non-) Nested URLs

TODO

### `SHOULD` Limit Number of Resource Types

TODO

### `SHOULD` Limit Number of Sub-Resource Levels

TODO


## HTTP Requests

TODO

### `MUST` Use HTTP Methods Correctly

TODO

### `MUST` Fulfill Common Method Properties

TODO

### `SHOULD` Consider To Design POST and PATCH Idempotent

TODO

### `SHOULD` Use Secondary Key for Idempotent POST Design

TODO

### `SHOULD` Define Collection Format of Query Parameters and Headers

TODO

### `MUST` Document Implicit Filtering

TODO


## HTTP Status Codes And Errors

TODO

### `MUST` Specify Success and Error Responses

TODO

### `MUST` Use Standard HTTP Status Codes

TODO

### `MUST` Use Most Specific HTTP Status Codes

TODO

### `MUST` Use Code 207 for Batch or Bulk Requests

TODO

### `MUST` Use Code 429 with Headers for Rate Limits

TODO

### `MUST` Use Problem JSON

TODO

### `MUST` Do not Expose Stack Traces

TODO


## Performance

TODO

### `SHOULD` Reduce Bandwidth Needs and Improve Responsiveness

TODO

### `SHOULD` Use gzip Compression

TODO

### `SHOULD` Support Partial Responses via Filtering

TODO

### `SHOULD` Allow Optional Embedding of Sub-Resources

TODO

### `MUST` Document Cachable GET, HEAD, and POST Endpoints

TODO


## Pagination

TODO


## Hypermedia

TODO

### `MUST` Use REST Maturity Level 2

TODO

### `MAY` Use REST Maturity Level 3 - HATEOAS

TODO

### `MUST` Use Full, Absolute URI

TODO

### `MUST` Use Common Hypertext Controls

TODO

### `SHOULD` Use Simple Hypertext Controls for Pagination and Self-References

TODO

### `MUST` Not Use Link Headers with JSON Entities

TODO


## Data Formats

TODO

### `MUST` Use JSON to Encode Structured Data

TODO

### `MAY` Use non-JSON Media Types for Binary Data or Alternative Content Representations

TODO

### `SHOULD` Prefer Standard Media Type Name `application/json`

TODO

### `MUST` Use Standard Date and Time Formats

TODO

### `MAY` Use Standards for Country, Language and Currency Codes

TODO

### `MUST` Define Format for Type Number and Integer TODO


## Common Data Types

TODO

### `SHOULD` Use a Common Money Object

TODO

### `MUST` Use Common Field Names and Semantics TODO


## Common Headers

TODO

### `MUST` Use Content-* Headers Correctly

TODO

### `MAY` Use Standardized Headers

TODO

### `MAY` Use Content-Location Header

TODO

### `SHOULD` Use Location Header Instead of Content-Location Header

TODO

### `MAY` Consider to Support Prefer Header to Handle Processing Preferences

TODO

### `MAY` Consider to Support ETag Together With If-Match/If-None-Match Header

TODO

### `MAY` Consider to Support Idempotency-Key Header TODO


## Proprietary Headers

TODO

### `MUST` Use Only the Specified Proprietary Zalando Headers

TODO

### `MUST` Propagate Proprietary Headers TODO


## API Operation

TODO

### `MUST` Publish OpenAPI Specification

TODO

### `SHOULD` Monitor API Usage

TODO

# TODO

- Rephrase the passages copied from other documentation (or cite it).